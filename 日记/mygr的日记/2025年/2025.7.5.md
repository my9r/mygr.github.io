

## T1

因为左右两边的分别是黑点和白点，所以其实两种颜色的点相互独立

所以对于黑点而言，其实就是限制了某个前缀最多选择多少个灰点

对于白点而言，其实就是限制了某个后缀最多选择多少个灰点

所以其实我们有一个最简单的dp

不妨设 $f_{i,j,k}$ 表示当前处理到第 $i$ 位，从左到右一共选择了 $j$ 个灰点，且左侧距离后缀限制最接近的差是多少

考虑下如果 $w$ 都相同可以怎么做？

忽然发现其实是可以费用流的，而且似乎是一个很典的模型

将其分为两层，第一层需要维护反边，

哦其实是第二层不需要连 $inf$ ，直接向右连接前缀最大值即可

所以我们每次能用的一定是一段后缀，上边也是同理



对边的建法有点问题

黑点反而应该求后缀和

而白点应该前缀和

还可以优化吗？

还是说去想T2？

先想三十分钟 T2 吧

感觉没头绪啊，还是来 T1 吧

发现他过大样例了，并且代码中并没有撤回横向边的相关语句

所以不妨猜想并不需要考虑横向流量的撤回


跑个大样例看看纵向边的撤回次数

发现是 $O(n)$ 级别的，flow的大手发力了

考虑如何暴力查询每个纵向的撤回点，并且暴力修改决策

考虑线段树上二分+矩阵乘法

编一下转移矩阵

若当前的 cho=0 ，则为

$$
\begin{bmatrix}
 0 & w\\
-\infty & 0\\
\end{bmatrix}$$

若当前的 cho=1 ，则为

$$
\begin{bmatrix}
 0 & -\infty\\
-w & 0\\
\end{bmatrix}$$
除此之外我们还需要转移 “是否能够往前转移”

$$\begin{bmatrix}
 [cx[0]=0]\times -\infty & -\infty\\
-\infty & [cx[1]=0]\times -\infty\\
\end{bmatrix}$$
我们规定奇数位置填往前转移矩阵，偶数位置则填cho矩阵


我们需要找第一个使得其与 $na$ 相同的位置


## T2

感觉就很想 MinMax 的样子

问题转化为 “最早有一个牌堆被填满的期望”



不妨设 $f(t)$ 表示结束时间大于等于 $t$ 的概率

那么答案即为 $\sum_{i}f(i)$

考虑设当前已经出现过的数的集合为 $T$ ，


当前手上的牌为 $x$ ，弃牌堆中的有 $y$

不妨设dp $f_{i,j,k}$ 表示当前添加到第 $i$ 种数，当前的 $x=i,y=j$

此时序列的大小为 $x+y$ ，枚举当前加入的数量 $c$

当 $c < b_i$ 时

