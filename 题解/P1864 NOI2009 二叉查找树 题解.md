首先根据 Treap 的性质得最后中序遍历的结果一定不变，所以考虑将每个点按照数据值排序

最后得到的 Treap 就是按照权值最值分治后得到的树

首先很容易想到将 “深度乘上访问频度” 转化为 “所有节点的 `size` 之和最小”，这样就将所有操作独立了

考虑枚举中点和左右子树，设 $f_{l,r}$ 表示区间 $l,r$ 这段形成一棵子树的最小代价，然后正常区间dp即可

但是这样子可能会出现一些问题，照我们现在的方法，则有若当前中点的权值比区间内其他位置的都要小，则只能修改当前位置的权值，但仍有一种可能是其他所有比其大的位置都已经被修改过了，所以我们需要记 $f_{l,r,i}$ 表示区间 $[l,r]$ ，其中未被修改的最大值为 $i$ 的最小代价，不妨设 $g_{l,r,i}=\min_{j=0}^{i}f_{l,r,j},d_{l,r,i}=\min_{j=i}^{n}f_{l,r,j}$，那么有状态转移方程

$$f_{l,r,i}=
sum_{l,r} + \min_{k\in[l,r]}
\begin{cases}
g_{l,k-1,i}+g_{k+1,r,i} & (key_k=i)\\
K+g_{l,k-1,i}+g_{k+1,r,i} & \text{otherwise}\\
\end{cases}
$$


